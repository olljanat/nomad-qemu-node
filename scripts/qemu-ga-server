#!/usr/bin/python3
import json
import socket
import sys
from http.server import BaseHTTPRequestHandler, HTTPServer
from socketserver import ThreadingMixIn
from urllib.parse import urlparse

SOCKET_BASE = "/data/nomad/alloc"
SOCKET_TIMEOUT = 3.0

SUPPORTED_COMMANDS = {
    "guest-ping",
    "guest-info",
    "guest-network-get-interfaces",
    "guest-get-osinfo",
}

# ---------- QGA helpers ----------
def read_json_line(sock: socket.socket):
    f = sock.makefile("rb", buffering=0)
    line = f.readline()
    if not line:
        raise TimeoutError("No data from QGA")
    return json.loads(line.decode("utf-8", errors="replace").strip())

def qga_call(alloc_id: str, task_name: str, command: str):
    if command not in SUPPORTED_COMMANDS:
        raise ValueError(f"Unsupported command: {command}")

    sock_path = f"{SOCKET_BASE}/{alloc_id}/{task_name}/qa.sock"
    cmd = {"execute": command}

    with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as s:
        s.settimeout(SOCKET_TIMEOUT)
        s.connect(sock_path)
        s.sendall((json.dumps(cmd) + "\r\n").encode("utf-8"))
        return read_json_line(s)

# ---------- HTTP server ----------
class QGAHandler(BaseHTTPRequestHandler):
    server_version = "QGA-HTTP/0.2"

    def _send(self, code: int, payload: dict):
        """
        Send a JSON response.
        Never raises BrokenPipeError if the client is already gone.
        """
        try:
            body = json.dumps(payload, indent=2).encode("utf-8")
            self.send_response(code)
            self.send_header("Content-Type", "application/json")
            self.send_header("Content-Length", str(len(body)))
            self.end_headers()
            self.wfile.write(body)
        except (BrokenPipeError, ConnectionResetError):
            # Client disconnected early â€” this is normal and safe to ignore
            pass

    def do_GET(self):
        parsed = urlparse(self.path)
        parts = parsed.path.strip("/").split("/")

        # /qga/<alloc>/<task>/<command>
        if len(parts) != 4 or parts[0] != "qga":
            self._send(400, {"error": "Invalid path"})
            return

        _, alloc_id, task_name, command = parts

        try:
            resp = qga_call(alloc_id, task_name, command)
        except ValueError as e:
            self._send(400, {"error": str(e)})
            return
        except FileNotFoundError:
            self._send(404, {"error": "QGA socket not found"})
            return
        except socket.timeout:
            self._send(504, {"error": "QGA timeout"})
            return
        except json.JSONDecodeError:
            self._send(502, {"error": "Invalid JSON from QGA"})
            return
        except OSError as e:
            self._send(502, {"error": f"Socket error: {e}"})
            return
        except Exception as e:
            self._send(500, {"error": str(e)})
            return

        # QGA-level error
        if "error" in resp:
            self._send(502, {
                "error": "QGA command failed",
                "qga_error": resp["error"],
            })
            return

        # Success
        self._send(200, resp.get("return", {}))

    # Silence default request logging
    def log_message(self, format, *args):
        return

class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
    daemon_threads = True

    # Silence scary tracebacks for broken connections
    def handle_error(self, request, client_address):
        pass

def main():
    server = ThreadedHTTPServer(("0.0.0.0", 8080), QGAHandler)
    print(f"QGA HTTP server listening on port 8080")
    server.serve_forever()

if __name__ == "__main__":
    main()
